{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _clsx = _interopRequireDefault(require(\"clsx\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _styles = require(\"@mui/material/styles\");\n\nvar _base = require(\"@mui/base\");\n\nvar _utils = require(\"@mui/material/utils\");\n\nvar _TreeViewContext = _interopRequireDefault(require(\"./TreeViewContext\"));\n\nvar _descendants = require(\"./descendants\");\n\nvar _treeViewClasses = require(\"./treeViewClasses\");\n\nvar _jsxRuntime = require(\"react/jsx-runtime\");\n\nconst _excluded = [\"children\", \"className\", \"defaultCollapseIcon\", \"defaultEndIcon\", \"defaultExpanded\", \"defaultExpandIcon\", \"defaultParentIcon\", \"defaultSelected\", \"disabledItemsFocusable\", \"disableSelection\", \"expanded\", \"id\", \"multiSelect\", \"onBlur\", \"onFocus\", \"onKeyDown\", \"onNodeFocus\", \"onNodeSelect\", \"onNodeToggle\", \"selected\"];\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst useUtilityClasses = ownerState => {\n  const {\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['root']\n  };\n  return (0, _base.unstable_composeClasses)(slots, _treeViewClasses.getTreeViewUtilityClass, classes);\n};\n\nconst TreeViewRoot = (0, _styles.styled)('ul', {\n  name: 'MuiTreeView',\n  slot: 'Root',\n  overridesResolver: (props, styles) => styles.root\n})({\n  padding: 0,\n  margin: 0,\n  listStyle: 'none',\n  outline: 0\n});\n\nfunction isPrintableCharacter(string) {\n  return string && string.length === 1 && string.match(/\\S/);\n}\n\nfunction findNextFirstChar(firstChars, startIndex, char) {\n  for (let i = startIndex; i < firstChars.length; i += 1) {\n    if (char === firstChars[i]) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction noopSelection() {\n  return false;\n}\n\nconst defaultDefaultExpanded = [];\nconst defaultDefaultSelected = [];\nconst TreeView = /*#__PURE__*/React.forwardRef(function TreeView(inProps, ref) {\n  const props = (0, _styles.useThemeProps)({\n    props: inProps,\n    name: 'MuiTreeView'\n  });\n  const {\n    children,\n    className,\n    defaultCollapseIcon,\n    defaultEndIcon,\n    defaultExpanded = defaultDefaultExpanded,\n    defaultExpandIcon,\n    defaultParentIcon,\n    defaultSelected = defaultDefaultSelected,\n    disabledItemsFocusable = false,\n    disableSelection = false,\n    expanded: expandedProp,\n    id: idProp,\n    multiSelect = false,\n    onBlur,\n    onFocus,\n    onKeyDown,\n    onNodeFocus,\n    onNodeSelect,\n    onNodeToggle,\n    selected: selectedProp\n  } = props,\n        other = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);\n  const theme = (0, _styles.useTheme)();\n  const isRtl = theme.direction === 'rtl';\n  const ownerState = (0, _extends2.default)({}, props, {\n    defaultExpanded,\n    defaultSelected,\n    disabledItemsFocusable,\n    disableSelection,\n    multiSelect\n  });\n  const classes = useUtilityClasses(ownerState);\n  const treeId = (0, _utils.unstable_useId)(idProp);\n  const treeRef = React.useRef(null);\n  const handleRef = (0, _utils.useForkRef)(treeRef, ref);\n  const [focusedNodeId, setFocusedNodeId] = React.useState(null);\n  const nodeMap = React.useRef({});\n  const firstCharMap = React.useRef({});\n  const [expanded, setExpandedState] = (0, _utils.useControlled)({\n    controlled: expandedProp,\n    default: defaultExpanded,\n    name: 'TreeView',\n    state: 'expanded'\n  });\n  const [selected, setSelectedState] = (0, _utils.useControlled)({\n    controlled: selectedProp,\n    default: defaultSelected,\n    name: 'TreeView',\n    state: 'selected'\n  });\n  /*\n   * Status Helpers\n   */\n\n  const isExpanded = React.useCallback(id => Array.isArray(expanded) ? expanded.indexOf(id) !== -1 : false, [expanded]);\n  const isExpandable = React.useCallback(id => nodeMap.current[id] && nodeMap.current[id].expandable, []);\n  const isSelected = React.useCallback(id => Array.isArray(selected) ? selected.indexOf(id) !== -1 : selected === id, [selected]);\n  const isDisabled = React.useCallback(id => {\n    let node = nodeMap.current[id]; // This can be called before the node has been added to the node map.\n\n    if (!node) {\n      return false;\n    }\n\n    if (node.disabled) {\n      return true;\n    }\n\n    while (node.parentId != null) {\n      node = nodeMap.current[node.parentId];\n\n      if (node.disabled) {\n        return true;\n      }\n    }\n\n    return false;\n  }, []);\n\n  const isFocused = id => focusedNodeId === id;\n  /*\n   * Child Helpers\n   */\n  // Using Object.keys -> .map to mimic Object.values we should replace with Object.values() once we stop IE11 support.\n\n\n  const getChildrenIds = id => Object.keys(nodeMap.current).map(key => {\n    return nodeMap.current[key];\n  }).filter(node => node.parentId === id).sort((a, b) => a.index - b.index).map(child => child.id);\n\n  const getNavigableChildrenIds = id => {\n    let childrenIds = getChildrenIds(id);\n\n    if (!disabledItemsFocusable) {\n      childrenIds = childrenIds.filter(node => !isDisabled(node));\n    }\n\n    return childrenIds;\n  };\n  /*\n   * Node Helpers\n   */\n\n\n  const getNextNode = id => {\n    // If expanded get first child\n    if (isExpanded(id) && getNavigableChildrenIds(id).length > 0) {\n      return getNavigableChildrenIds(id)[0];\n    }\n\n    let node = nodeMap.current[id];\n\n    while (node != null) {\n      // Try to get next sibling\n      const siblings = getNavigableChildrenIds(node.parentId);\n      const nextSibling = siblings[siblings.indexOf(node.id) + 1];\n\n      if (nextSibling) {\n        return nextSibling;\n      } // If the sibling does not exist, go up a level to the parent and try again.\n\n\n      node = nodeMap.current[node.parentId];\n    }\n\n    return null;\n  };\n\n  const getPreviousNode = id => {\n    const node = nodeMap.current[id];\n    const siblings = getNavigableChildrenIds(node.parentId);\n    const nodeIndex = siblings.indexOf(id);\n\n    if (nodeIndex === 0) {\n      return node.parentId;\n    }\n\n    let currentNode = siblings[nodeIndex - 1];\n\n    while (isExpanded(currentNode) && getNavigableChildrenIds(currentNode).length > 0) {\n      currentNode = getNavigableChildrenIds(currentNode).pop();\n    }\n\n    return currentNode;\n  };\n\n  const getLastNode = () => {\n    let lastNode = getNavigableChildrenIds(null).pop();\n\n    while (isExpanded(lastNode)) {\n      lastNode = getNavigableChildrenIds(lastNode).pop();\n    }\n\n    return lastNode;\n  };\n\n  const getFirstNode = () => getNavigableChildrenIds(null)[0];\n\n  const getParent = id => nodeMap.current[id].parentId;\n  /**\n   * This is used to determine the start and end of a selection range so\n   * we can get the nodes between the two border nodes.\n   *\n   * It finds the nodes' common ancestor using\n   * a naive implementation of a lowest common ancestor algorithm\n   * (https://en.wikipedia.org/wiki/Lowest_common_ancestor).\n   * Then compares the ancestor's 2 children that are ancestors of nodeA and NodeB\n   * so we can compare their indexes to work out which node comes first in a depth first search.\n   * (https://en.wikipedia.org/wiki/Depth-first_search)\n   *\n   * Another way to put it is which node is shallower in a trÃ©maux tree\n   * https://en.wikipedia.org/wiki/Tr%C3%A9maux_tree\n   */\n\n\n  const findOrderInTremauxTree = (nodeAId, nodeBId) => {\n    if (nodeAId === nodeBId) {\n      return [nodeAId, nodeBId];\n    }\n\n    const nodeA = nodeMap.current[nodeAId];\n    const nodeB = nodeMap.current[nodeBId];\n\n    if (nodeA.parentId === nodeB.id || nodeB.parentId === nodeA.id) {\n      return nodeB.parentId === nodeA.id ? [nodeA.id, nodeB.id] : [nodeB.id, nodeA.id];\n    }\n\n    const aFamily = [nodeA.id];\n    const bFamily = [nodeB.id];\n    let aAncestor = nodeA.parentId;\n    let bAncestor = nodeB.parentId;\n    let aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n    let bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n    let continueA = true;\n    let continueB = true;\n\n    while (!bAncestorIsCommon && !aAncestorIsCommon) {\n      if (continueA) {\n        aFamily.push(aAncestor);\n        aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n        continueA = aAncestor !== null;\n\n        if (!aAncestorIsCommon && continueA) {\n          aAncestor = nodeMap.current[aAncestor].parentId;\n        }\n      }\n\n      if (continueB && !aAncestorIsCommon) {\n        bFamily.push(bAncestor);\n        bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n        continueB = bAncestor !== null;\n\n        if (!bAncestorIsCommon && continueB) {\n          bAncestor = nodeMap.current[bAncestor].parentId;\n        }\n      }\n    }\n\n    const commonAncestor = aAncestorIsCommon ? aAncestor : bAncestor;\n    const ancestorFamily = getChildrenIds(commonAncestor);\n    const aSide = aFamily[aFamily.indexOf(commonAncestor) - 1];\n    const bSide = bFamily[bFamily.indexOf(commonAncestor) - 1];\n    return ancestorFamily.indexOf(aSide) < ancestorFamily.indexOf(bSide) ? [nodeAId, nodeBId] : [nodeBId, nodeAId];\n  };\n\n  const getNodesInRange = (nodeA, nodeB) => {\n    const [first, last] = findOrderInTremauxTree(nodeA, nodeB);\n    const nodes = [first];\n    let current = first;\n\n    while (current !== last) {\n      current = getNextNode(current);\n      nodes.push(current);\n    }\n\n    return nodes;\n  };\n  /*\n   * Focus Helpers\n   */\n\n\n  const focus = (event, id) => {\n    if (id) {\n      setFocusedNodeId(id);\n\n      if (onNodeFocus) {\n        onNodeFocus(event, id);\n      }\n    }\n  };\n\n  const focusNextNode = (event, id) => focus(event, getNextNode(id));\n\n  const focusPreviousNode = (event, id) => focus(event, getPreviousNode(id));\n\n  const focusFirstNode = event => focus(event, getFirstNode());\n\n  const focusLastNode = event => focus(event, getLastNode());\n\n  const focusByFirstCharacter = (event, id, char) => {\n    let start;\n    let index;\n    const lowercaseChar = char.toLowerCase();\n    const firstCharIds = [];\n    const firstChars = []; // This really only works since the ids are strings\n\n    Object.keys(firstCharMap.current).forEach(nodeId => {\n      const firstChar = firstCharMap.current[nodeId];\n      const map = nodeMap.current[nodeId];\n      const visible = map.parentId ? isExpanded(map.parentId) : true;\n      const shouldBeSkipped = disabledItemsFocusable ? false : isDisabled(nodeId);\n\n      if (visible && !shouldBeSkipped) {\n        firstCharIds.push(nodeId);\n        firstChars.push(firstChar);\n      }\n    }); // Get start index for search based on position of currentItem\n\n    start = firstCharIds.indexOf(id) + 1;\n\n    if (start >= firstCharIds.length) {\n      start = 0;\n    } // Check remaining slots in the menu\n\n\n    index = findNextFirstChar(firstChars, start, lowercaseChar); // If not found in remaining slots, check from beginning\n\n    if (index === -1) {\n      index = findNextFirstChar(firstChars, 0, lowercaseChar);\n    } // If match was found...\n\n\n    if (index > -1) {\n      focus(event, firstCharIds[index]);\n    }\n  };\n  /*\n   * Expansion Helpers\n   */\n\n\n  const toggleExpansion = function (event) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : focusedNodeId;\n    let newExpanded;\n\n    if (expanded.indexOf(value) !== -1) {\n      newExpanded = expanded.filter(id => id !== value);\n    } else {\n      newExpanded = [value].concat(expanded);\n    }\n\n    if (onNodeToggle) {\n      onNodeToggle(event, newExpanded);\n    }\n\n    setExpandedState(newExpanded);\n  };\n\n  const expandAllSiblings = (event, id) => {\n    const map = nodeMap.current[id];\n    const siblings = getChildrenIds(map.parentId);\n    const diff = siblings.filter(child => isExpandable(child) && !isExpanded(child));\n    const newExpanded = expanded.concat(diff);\n\n    if (diff.length > 0) {\n      setExpandedState(newExpanded);\n\n      if (onNodeToggle) {\n        onNodeToggle(event, newExpanded);\n      }\n    }\n  };\n  /*\n   * Selection Helpers\n   */\n\n\n  const lastSelectedNode = React.useRef(null);\n  const lastSelectionWasRange = React.useRef(false);\n  const currentRangeSelection = React.useRef([]);\n\n  const handleRangeArrowSelect = (event, nodes) => {\n    let base = selected.slice();\n    const {\n      start,\n      next,\n      current\n    } = nodes;\n\n    if (!next || !current) {\n      return;\n    }\n\n    if (currentRangeSelection.current.indexOf(current) === -1) {\n      currentRangeSelection.current = [];\n    }\n\n    if (lastSelectionWasRange.current) {\n      if (currentRangeSelection.current.indexOf(next) !== -1) {\n        base = base.filter(id => id === start || id !== current);\n        currentRangeSelection.current = currentRangeSelection.current.filter(id => id === start || id !== current);\n      } else {\n        base.push(next);\n        currentRangeSelection.current.push(next);\n      }\n    } else {\n      base.push(next);\n      currentRangeSelection.current.push(current, next);\n    }\n\n    if (onNodeSelect) {\n      onNodeSelect(event, base);\n    }\n\n    setSelectedState(base);\n  };\n\n  const handleRangeSelect = (event, nodes) => {\n    let base = selected.slice();\n    const {\n      start,\n      end\n    } = nodes; // If last selection was a range selection ignore nodes that were selected.\n\n    if (lastSelectionWasRange.current) {\n      base = base.filter(id => currentRangeSelection.current.indexOf(id) === -1);\n    }\n\n    let range = getNodesInRange(start, end);\n    range = range.filter(node => !isDisabled(node));\n    currentRangeSelection.current = range;\n    let newSelected = base.concat(range);\n    newSelected = newSelected.filter((id, i) => newSelected.indexOf(id) === i);\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const handleMultipleSelect = (event, value) => {\n    let newSelected;\n\n    if (selected.indexOf(value) !== -1) {\n      newSelected = selected.filter(id => id !== value);\n    } else {\n      newSelected = [value].concat(selected);\n    }\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const handleSingleSelect = (event, value) => {\n    const newSelected = multiSelect ? [value] : value;\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const selectNode = function (event, id) {\n    let multiple = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (id) {\n      if (multiple) {\n        handleMultipleSelect(event, id);\n      } else {\n        handleSingleSelect(event, id);\n      }\n\n      lastSelectedNode.current = id;\n      lastSelectionWasRange.current = false;\n      currentRangeSelection.current = [];\n      return true;\n    }\n\n    return false;\n  };\n\n  const selectRange = function (event, nodes) {\n    let stacked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const {\n      start = lastSelectedNode.current,\n      end,\n      current\n    } = nodes;\n\n    if (stacked) {\n      handleRangeArrowSelect(event, {\n        start,\n        next: end,\n        current\n      });\n    } else if (start != null && end != null) {\n      handleRangeSelect(event, {\n        start,\n        end\n      });\n    }\n\n    lastSelectionWasRange.current = true;\n  };\n\n  const rangeSelectToFirst = (event, id) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n    selectRange(event, {\n      start,\n      end: getFirstNode()\n    });\n  };\n\n  const rangeSelectToLast = (event, id) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n    selectRange(event, {\n      start,\n      end: getLastNode()\n    });\n  };\n\n  const selectNextNode = (event, id) => {\n    if (!isDisabled(getNextNode(id))) {\n      selectRange(event, {\n        end: getNextNode(id),\n        current: id\n      }, true);\n    }\n  };\n\n  const selectPreviousNode = (event, id) => {\n    if (!isDisabled(getPreviousNode(id))) {\n      selectRange(event, {\n        end: getPreviousNode(id),\n        current: id\n      }, true);\n    }\n  };\n\n  const selectAllNodes = event => {\n    selectRange(event, {\n      start: getFirstNode(),\n      end: getLastNode()\n    });\n  };\n  /*\n   * Mapping Helpers\n   */\n\n\n  const registerNode = React.useCallback(node => {\n    const {\n      id,\n      index,\n      parentId,\n      expandable,\n      idAttribute,\n      disabled\n    } = node;\n    nodeMap.current[id] = {\n      id,\n      index,\n      parentId,\n      expandable,\n      idAttribute,\n      disabled\n    };\n  }, []);\n  const unregisterNode = React.useCallback(id => {\n    const newMap = (0, _extends2.default)({}, nodeMap.current);\n    delete newMap[id];\n    nodeMap.current = newMap;\n    setFocusedNodeId(oldFocusedNodeId => {\n      if (oldFocusedNodeId === id && treeRef.current === (0, _utils.ownerDocument)(treeRef.current).activeElement) {\n        return getChildrenIds(null)[0];\n      }\n\n      return oldFocusedNodeId;\n    });\n  }, []);\n  const mapFirstChar = React.useCallback((id, firstChar) => {\n    firstCharMap.current[id] = firstChar;\n  }, []);\n  const unMapFirstChar = React.useCallback(id => {\n    const newMap = (0, _extends2.default)({}, firstCharMap.current);\n    delete newMap[id];\n    firstCharMap.current = newMap;\n  }, []);\n  /**\n   * Event handlers and Navigation\n   */\n\n  const handleNextArrow = event => {\n    if (isExpandable(focusedNodeId)) {\n      if (isExpanded(focusedNodeId)) {\n        focusNextNode(event, focusedNodeId);\n      } else if (!isDisabled(focusedNodeId)) {\n        toggleExpansion(event);\n      }\n    }\n\n    return true;\n  };\n\n  const handlePreviousArrow = event => {\n    if (isExpanded(focusedNodeId) && !isDisabled(focusedNodeId)) {\n      toggleExpansion(event, focusedNodeId);\n      return true;\n    }\n\n    const parent = getParent(focusedNodeId);\n\n    if (parent) {\n      focus(event, parent);\n      return true;\n    }\n\n    return false;\n  };\n\n  const handleKeyDown = event => {\n    let flag = false;\n    const key = event.key; // If the tree is empty there will be no focused node\n\n    if (event.altKey || event.currentTarget !== event.target || !focusedNodeId) {\n      return;\n    }\n\n    const ctrlPressed = event.ctrlKey || event.metaKey;\n\n    switch (key) {\n      case ' ':\n        if (!disableSelection && !isDisabled(focusedNodeId)) {\n          if (multiSelect && event.shiftKey) {\n            selectRange(event, {\n              end: focusedNodeId\n            });\n            flag = true;\n          } else if (multiSelect) {\n            flag = selectNode(event, focusedNodeId, true);\n          } else {\n            flag = selectNode(event, focusedNodeId);\n          }\n        }\n\n        event.stopPropagation();\n        break;\n\n      case 'Enter':\n        if (!isDisabled(focusedNodeId)) {\n          if (isExpandable(focusedNodeId)) {\n            toggleExpansion(event);\n            flag = true;\n          } else if (multiSelect) {\n            flag = selectNode(event, focusedNodeId, true);\n          } else {\n            flag = selectNode(event, focusedNodeId);\n          }\n        }\n\n        event.stopPropagation();\n        break;\n\n      case 'ArrowDown':\n        if (multiSelect && event.shiftKey && !disableSelection) {\n          selectNextNode(event, focusedNodeId);\n        }\n\n        focusNextNode(event, focusedNodeId);\n        flag = true;\n        break;\n\n      case 'ArrowUp':\n        if (multiSelect && event.shiftKey && !disableSelection) {\n          selectPreviousNode(event, focusedNodeId);\n        }\n\n        focusPreviousNode(event, focusedNodeId);\n        flag = true;\n        break;\n\n      case 'ArrowRight':\n        if (isRtl) {\n          flag = handlePreviousArrow(event);\n        } else {\n          flag = handleNextArrow(event);\n        }\n\n        break;\n\n      case 'ArrowLeft':\n        if (isRtl) {\n          flag = handleNextArrow(event);\n        } else {\n          flag = handlePreviousArrow(event);\n        }\n\n        break;\n\n      case 'Home':\n        if (multiSelect && ctrlPressed && event.shiftKey && !disableSelection && !isDisabled(focusedNodeId)) {\n          rangeSelectToFirst(event, focusedNodeId);\n        }\n\n        focusFirstNode(event);\n        flag = true;\n        break;\n\n      case 'End':\n        if (multiSelect && ctrlPressed && event.shiftKey && !disableSelection && !isDisabled(focusedNodeId)) {\n          rangeSelectToLast(event, focusedNodeId);\n        }\n\n        focusLastNode(event);\n        flag = true;\n        break;\n\n      default:\n        if (key === '*') {\n          expandAllSiblings(event, focusedNodeId);\n          flag = true;\n        } else if (multiSelect && ctrlPressed && key.toLowerCase() === 'a' && !disableSelection) {\n          selectAllNodes(event);\n          flag = true;\n        } else if (!ctrlPressed && !event.shiftKey && isPrintableCharacter(key)) {\n          focusByFirstCharacter(event, focusedNodeId, key);\n          flag = true;\n        }\n\n    }\n\n    if (flag) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n  };\n\n  const handleFocus = event => {\n    // if the event bubbled (which is React specific) we don't want to steal focus\n    if (event.target === event.currentTarget) {\n      const firstSelected = Array.isArray(selected) ? selected[0] : selected;\n      focus(event, firstSelected || getNavigableChildrenIds(null)[0]);\n    }\n\n    if (onFocus) {\n      onFocus(event);\n    }\n  };\n\n  const handleBlur = event => {\n    setFocusedNodeId(null);\n\n    if (onBlur) {\n      onBlur(event);\n    }\n  };\n\n  const activeDescendant = nodeMap.current[focusedNodeId] ? nodeMap.current[focusedNodeId].idAttribute : null;\n  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_TreeViewContext.default.Provider, {\n    value: {\n      icons: {\n        defaultCollapseIcon,\n        defaultExpandIcon,\n        defaultParentIcon,\n        defaultEndIcon\n      },\n      focus,\n      toggleExpansion,\n      isExpanded,\n      isExpandable,\n      isFocused,\n      isSelected,\n      isDisabled,\n      selectNode: disableSelection ? noopSelection : selectNode,\n      selectRange: disableSelection ? noopSelection : selectRange,\n      multiSelect,\n      disabledItemsFocusable,\n      mapFirstChar,\n      unMapFirstChar,\n      registerNode,\n      unregisterNode,\n      treeId\n    },\n    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_descendants.DescendantProvider, {\n      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(TreeViewRoot, (0, _extends2.default)({\n        role: \"tree\",\n        id: treeId,\n        \"aria-activedescendant\": activeDescendant,\n        \"aria-multiselectable\": multiSelect,\n        className: (0, _clsx.default)(classes.root, className),\n        ref: handleRef,\n        tabIndex: 0,\n        onKeyDown: handleKeyDown,\n        onFocus: handleFocus,\n        onBlur: handleBlur,\n        ownerState: ownerState\n      }, other, {\n        children: children\n      }))\n    })\n  });\n});\nprocess.env.NODE_ENV !== \"production\" ? TreeView.propTypes\n/* remove-proptypes */\n= {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n\n  /**\n   * The content of the component.\n   */\n  children: _propTypes.default.node,\n\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: _propTypes.default.object,\n\n  /**\n   * @ignore\n   */\n  className: _propTypes.default.string,\n\n  /**\n   * The default icon used to collapse the node.\n   */\n  defaultCollapseIcon: _propTypes.default.node,\n\n  /**\n   * The default icon displayed next to a end node. This is applied to all\n   * tree nodes and can be overridden by the TreeItem `icon` prop.\n   */\n  defaultEndIcon: _propTypes.default.node,\n\n  /**\n   * Expanded node ids. (Uncontrolled)\n   * @default []\n   */\n  defaultExpanded: _propTypes.default.arrayOf(_propTypes.default.string),\n\n  /**\n   * The default icon used to expand the node.\n   */\n  defaultExpandIcon: _propTypes.default.node,\n\n  /**\n   * The default icon displayed next to a parent node. This is applied to all\n   * parent nodes and can be overridden by the TreeItem `icon` prop.\n   */\n  defaultParentIcon: _propTypes.default.node,\n\n  /**\n   * Selected node ids. (Uncontrolled)\n   * When `multiSelect` is true this takes an array of strings; when false (default) a string.\n   * @default []\n   */\n  defaultSelected: _propTypes.default.oneOfType([_propTypes.default.arrayOf(_propTypes.default.string), _propTypes.default.string]),\n\n  /**\n   * If `true`, will allow focus on disabled items.\n   * @default false\n   */\n  disabledItemsFocusable: _propTypes.default.bool,\n\n  /**\n   * If `true` selection is disabled.\n   * @default false\n   */\n  disableSelection: _propTypes.default.bool,\n\n  /**\n   * Expanded node ids. (Controlled)\n   */\n  expanded: _propTypes.default.arrayOf(_propTypes.default.string),\n\n  /**\n   * This prop is used to help implement the accessibility logic.\n   * If you don't provide this prop. It falls back to a randomly generated id.\n   */\n  id: _propTypes.default.string,\n\n  /**\n   * If true `ctrl` and `shift` will trigger multiselect.\n   * @default false\n   */\n  multiSelect: _propTypes.default.bool,\n\n  /**\n   * @ignore\n   */\n  onBlur: _propTypes.default.func,\n\n  /**\n   * @ignore\n   */\n  onFocus: _propTypes.default.func,\n\n  /**\n   * @ignore\n   */\n  onKeyDown: _propTypes.default.func,\n\n  /**\n   * Callback fired when tree items are focused.\n   *\n   * @param {React.SyntheticEvent} event The event source of the callback **Warning**: This is a generic event not a focus event.\n   * @param {string} value of the focused node.\n   */\n  onNodeFocus: _propTypes.default.func,\n\n  /**\n   * Callback fired when tree items are selected/unselected.\n   *\n   * @param {React.SyntheticEvent} event The event source of the callback\n   * @param {string[] | string} nodeIds Ids of the selected nodes. When `multiSelect` is true\n   * this is an array of strings; when false (default) a string.\n   */\n  onNodeSelect: _propTypes.default.func,\n\n  /**\n   * Callback fired when tree items are expanded/collapsed.\n   *\n   * @param {React.SyntheticEvent} event The event source of the callback.\n   * @param {array} nodeIds The ids of the expanded nodes.\n   */\n  onNodeToggle: _propTypes.default.func,\n\n  /**\n   * Selected node ids. (Controlled)\n   * When `multiSelect` is true this takes an array of strings; when false (default) a string.\n   */\n  selected: _propTypes.default.oneOfType([_propTypes.default.arrayOf(_propTypes.default.string), _propTypes.default.string]),\n\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: _propTypes.default.oneOfType([_propTypes.default.arrayOf(_propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.object, _propTypes.default.bool])), _propTypes.default.func, _propTypes.default.object])\n} : void 0;\nvar _default = TreeView;\nexports.default = _default;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_extends2","_objectWithoutPropertiesLoose2","React","_interopRequireWildcard","_clsx","_propTypes","_styles","_base","_utils","_TreeViewContext","_descendants","_treeViewClasses","_jsxRuntime","_excluded","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","useUtilityClasses","ownerState","classes","slots","root","unstable_composeClasses","getTreeViewUtilityClass","TreeViewRoot","styled","name","slot","overridesResolver","props","styles","padding","margin","listStyle","outline","isPrintableCharacter","string","length","match","findNextFirstChar","firstChars","startIndex","char","i","noopSelection","defaultDefaultExpanded","defaultDefaultSelected","TreeView","forwardRef","inProps","ref","useThemeProps","children","className","defaultCollapseIcon","defaultEndIcon","defaultExpanded","defaultExpandIcon","defaultParentIcon","defaultSelected","disabledItemsFocusable","disableSelection","expanded","expandedProp","id","idProp","multiSelect","onBlur","onFocus","onKeyDown","onNodeFocus","onNodeSelect","onNodeToggle","selected","selectedProp","other","theme","useTheme","isRtl","direction","treeId","unstable_useId","treeRef","useRef","handleRef","useForkRef","focusedNodeId","setFocusedNodeId","useState","nodeMap","firstCharMap","setExpandedState","useControlled","controlled","state","setSelectedState","isExpanded","useCallback","Array","isArray","indexOf","isExpandable","current","expandable","isSelected","isDisabled","node","disabled","parentId","isFocused","getChildrenIds","keys","map","filter","sort","a","b","index","child","getNavigableChildrenIds","childrenIds","getNextNode","siblings","nextSibling","getPreviousNode","nodeIndex","currentNode","pop","getLastNode","lastNode","getFirstNode","getParent","findOrderInTremauxTree","nodeAId","nodeBId","nodeA","nodeB","aFamily","bFamily","aAncestor","bAncestor","aAncestorIsCommon","bAncestorIsCommon","continueA","continueB","push","commonAncestor","ancestorFamily","aSide","bSide","getNodesInRange","first","last","nodes","focus","event","focusNextNode","focusPreviousNode","focusFirstNode","focusLastNode","focusByFirstCharacter","start","lowercaseChar","toLowerCase","firstCharIds","forEach","nodeId","firstChar","visible","shouldBeSkipped","toggleExpansion","newExpanded","concat","expandAllSiblings","diff","lastSelectedNode","lastSelectionWasRange","currentRangeSelection","handleRangeArrowSelect","base","slice","next","handleRangeSelect","end","range","newSelected","handleMultipleSelect","handleSingleSelect","selectNode","multiple","selectRange","stacked","rangeSelectToFirst","rangeSelectToLast","selectNextNode","selectPreviousNode","selectAllNodes","registerNode","idAttribute","unregisterNode","newMap","oldFocusedNodeId","ownerDocument","activeElement","mapFirstChar","unMapFirstChar","handleNextArrow","handlePreviousArrow","parent","handleKeyDown","flag","altKey","currentTarget","target","ctrlPressed","ctrlKey","metaKey","shiftKey","stopPropagation","preventDefault","handleFocus","firstSelected","handleBlur","activeDescendant","jsx","Provider","icons","DescendantProvider","role","tabIndex","process","env","NODE_ENV","propTypes","object","arrayOf","oneOfType","bool","func","sx","_default"],"sources":["C:/Users/Admin/Desktop/learn React/time-sheet - Copy/node_modules/@mui/lab/node/TreeView/TreeView.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _clsx = _interopRequireDefault(require(\"clsx\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _styles = require(\"@mui/material/styles\");\n\nvar _base = require(\"@mui/base\");\n\nvar _utils = require(\"@mui/material/utils\");\n\nvar _TreeViewContext = _interopRequireDefault(require(\"./TreeViewContext\"));\n\nvar _descendants = require(\"./descendants\");\n\nvar _treeViewClasses = require(\"./treeViewClasses\");\n\nvar _jsxRuntime = require(\"react/jsx-runtime\");\n\nconst _excluded = [\"children\", \"className\", \"defaultCollapseIcon\", \"defaultEndIcon\", \"defaultExpanded\", \"defaultExpandIcon\", \"defaultParentIcon\", \"defaultSelected\", \"disabledItemsFocusable\", \"disableSelection\", \"expanded\", \"id\", \"multiSelect\", \"onBlur\", \"onFocus\", \"onKeyDown\", \"onNodeFocus\", \"onNodeSelect\", \"onNodeToggle\", \"selected\"];\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst useUtilityClasses = ownerState => {\n  const {\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['root']\n  };\n  return (0, _base.unstable_composeClasses)(slots, _treeViewClasses.getTreeViewUtilityClass, classes);\n};\n\nconst TreeViewRoot = (0, _styles.styled)('ul', {\n  name: 'MuiTreeView',\n  slot: 'Root',\n  overridesResolver: (props, styles) => styles.root\n})({\n  padding: 0,\n  margin: 0,\n  listStyle: 'none',\n  outline: 0\n});\n\nfunction isPrintableCharacter(string) {\n  return string && string.length === 1 && string.match(/\\S/);\n}\n\nfunction findNextFirstChar(firstChars, startIndex, char) {\n  for (let i = startIndex; i < firstChars.length; i += 1) {\n    if (char === firstChars[i]) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction noopSelection() {\n  return false;\n}\n\nconst defaultDefaultExpanded = [];\nconst defaultDefaultSelected = [];\nconst TreeView = /*#__PURE__*/React.forwardRef(function TreeView(inProps, ref) {\n  const props = (0, _styles.useThemeProps)({\n    props: inProps,\n    name: 'MuiTreeView'\n  });\n  const {\n    children,\n    className,\n    defaultCollapseIcon,\n    defaultEndIcon,\n    defaultExpanded = defaultDefaultExpanded,\n    defaultExpandIcon,\n    defaultParentIcon,\n    defaultSelected = defaultDefaultSelected,\n    disabledItemsFocusable = false,\n    disableSelection = false,\n    expanded: expandedProp,\n    id: idProp,\n    multiSelect = false,\n    onBlur,\n    onFocus,\n    onKeyDown,\n    onNodeFocus,\n    onNodeSelect,\n    onNodeToggle,\n    selected: selectedProp\n  } = props,\n        other = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded);\n  const theme = (0, _styles.useTheme)();\n  const isRtl = theme.direction === 'rtl';\n  const ownerState = (0, _extends2.default)({}, props, {\n    defaultExpanded,\n    defaultSelected,\n    disabledItemsFocusable,\n    disableSelection,\n    multiSelect\n  });\n  const classes = useUtilityClasses(ownerState);\n  const treeId = (0, _utils.unstable_useId)(idProp);\n  const treeRef = React.useRef(null);\n  const handleRef = (0, _utils.useForkRef)(treeRef, ref);\n  const [focusedNodeId, setFocusedNodeId] = React.useState(null);\n  const nodeMap = React.useRef({});\n  const firstCharMap = React.useRef({});\n  const [expanded, setExpandedState] = (0, _utils.useControlled)({\n    controlled: expandedProp,\n    default: defaultExpanded,\n    name: 'TreeView',\n    state: 'expanded'\n  });\n  const [selected, setSelectedState] = (0, _utils.useControlled)({\n    controlled: selectedProp,\n    default: defaultSelected,\n    name: 'TreeView',\n    state: 'selected'\n  });\n  /*\n   * Status Helpers\n   */\n\n  const isExpanded = React.useCallback(id => Array.isArray(expanded) ? expanded.indexOf(id) !== -1 : false, [expanded]);\n  const isExpandable = React.useCallback(id => nodeMap.current[id] && nodeMap.current[id].expandable, []);\n  const isSelected = React.useCallback(id => Array.isArray(selected) ? selected.indexOf(id) !== -1 : selected === id, [selected]);\n  const isDisabled = React.useCallback(id => {\n    let node = nodeMap.current[id]; // This can be called before the node has been added to the node map.\n\n    if (!node) {\n      return false;\n    }\n\n    if (node.disabled) {\n      return true;\n    }\n\n    while (node.parentId != null) {\n      node = nodeMap.current[node.parentId];\n\n      if (node.disabled) {\n        return true;\n      }\n    }\n\n    return false;\n  }, []);\n\n  const isFocused = id => focusedNodeId === id;\n  /*\n   * Child Helpers\n   */\n  // Using Object.keys -> .map to mimic Object.values we should replace with Object.values() once we stop IE11 support.\n\n\n  const getChildrenIds = id => Object.keys(nodeMap.current).map(key => {\n    return nodeMap.current[key];\n  }).filter(node => node.parentId === id).sort((a, b) => a.index - b.index).map(child => child.id);\n\n  const getNavigableChildrenIds = id => {\n    let childrenIds = getChildrenIds(id);\n\n    if (!disabledItemsFocusable) {\n      childrenIds = childrenIds.filter(node => !isDisabled(node));\n    }\n\n    return childrenIds;\n  };\n  /*\n   * Node Helpers\n   */\n\n\n  const getNextNode = id => {\n    // If expanded get first child\n    if (isExpanded(id) && getNavigableChildrenIds(id).length > 0) {\n      return getNavigableChildrenIds(id)[0];\n    }\n\n    let node = nodeMap.current[id];\n\n    while (node != null) {\n      // Try to get next sibling\n      const siblings = getNavigableChildrenIds(node.parentId);\n      const nextSibling = siblings[siblings.indexOf(node.id) + 1];\n\n      if (nextSibling) {\n        return nextSibling;\n      } // If the sibling does not exist, go up a level to the parent and try again.\n\n\n      node = nodeMap.current[node.parentId];\n    }\n\n    return null;\n  };\n\n  const getPreviousNode = id => {\n    const node = nodeMap.current[id];\n    const siblings = getNavigableChildrenIds(node.parentId);\n    const nodeIndex = siblings.indexOf(id);\n\n    if (nodeIndex === 0) {\n      return node.parentId;\n    }\n\n    let currentNode = siblings[nodeIndex - 1];\n\n    while (isExpanded(currentNode) && getNavigableChildrenIds(currentNode).length > 0) {\n      currentNode = getNavigableChildrenIds(currentNode).pop();\n    }\n\n    return currentNode;\n  };\n\n  const getLastNode = () => {\n    let lastNode = getNavigableChildrenIds(null).pop();\n\n    while (isExpanded(lastNode)) {\n      lastNode = getNavigableChildrenIds(lastNode).pop();\n    }\n\n    return lastNode;\n  };\n\n  const getFirstNode = () => getNavigableChildrenIds(null)[0];\n\n  const getParent = id => nodeMap.current[id].parentId;\n  /**\n   * This is used to determine the start and end of a selection range so\n   * we can get the nodes between the two border nodes.\n   *\n   * It finds the nodes' common ancestor using\n   * a naive implementation of a lowest common ancestor algorithm\n   * (https://en.wikipedia.org/wiki/Lowest_common_ancestor).\n   * Then compares the ancestor's 2 children that are ancestors of nodeA and NodeB\n   * so we can compare their indexes to work out which node comes first in a depth first search.\n   * (https://en.wikipedia.org/wiki/Depth-first_search)\n   *\n   * Another way to put it is which node is shallower in a trÃ©maux tree\n   * https://en.wikipedia.org/wiki/Tr%C3%A9maux_tree\n   */\n\n\n  const findOrderInTremauxTree = (nodeAId, nodeBId) => {\n    if (nodeAId === nodeBId) {\n      return [nodeAId, nodeBId];\n    }\n\n    const nodeA = nodeMap.current[nodeAId];\n    const nodeB = nodeMap.current[nodeBId];\n\n    if (nodeA.parentId === nodeB.id || nodeB.parentId === nodeA.id) {\n      return nodeB.parentId === nodeA.id ? [nodeA.id, nodeB.id] : [nodeB.id, nodeA.id];\n    }\n\n    const aFamily = [nodeA.id];\n    const bFamily = [nodeB.id];\n    let aAncestor = nodeA.parentId;\n    let bAncestor = nodeB.parentId;\n    let aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n    let bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n    let continueA = true;\n    let continueB = true;\n\n    while (!bAncestorIsCommon && !aAncestorIsCommon) {\n      if (continueA) {\n        aFamily.push(aAncestor);\n        aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n        continueA = aAncestor !== null;\n\n        if (!aAncestorIsCommon && continueA) {\n          aAncestor = nodeMap.current[aAncestor].parentId;\n        }\n      }\n\n      if (continueB && !aAncestorIsCommon) {\n        bFamily.push(bAncestor);\n        bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n        continueB = bAncestor !== null;\n\n        if (!bAncestorIsCommon && continueB) {\n          bAncestor = nodeMap.current[bAncestor].parentId;\n        }\n      }\n    }\n\n    const commonAncestor = aAncestorIsCommon ? aAncestor : bAncestor;\n    const ancestorFamily = getChildrenIds(commonAncestor);\n    const aSide = aFamily[aFamily.indexOf(commonAncestor) - 1];\n    const bSide = bFamily[bFamily.indexOf(commonAncestor) - 1];\n    return ancestorFamily.indexOf(aSide) < ancestorFamily.indexOf(bSide) ? [nodeAId, nodeBId] : [nodeBId, nodeAId];\n  };\n\n  const getNodesInRange = (nodeA, nodeB) => {\n    const [first, last] = findOrderInTremauxTree(nodeA, nodeB);\n    const nodes = [first];\n    let current = first;\n\n    while (current !== last) {\n      current = getNextNode(current);\n      nodes.push(current);\n    }\n\n    return nodes;\n  };\n  /*\n   * Focus Helpers\n   */\n\n\n  const focus = (event, id) => {\n    if (id) {\n      setFocusedNodeId(id);\n\n      if (onNodeFocus) {\n        onNodeFocus(event, id);\n      }\n    }\n  };\n\n  const focusNextNode = (event, id) => focus(event, getNextNode(id));\n\n  const focusPreviousNode = (event, id) => focus(event, getPreviousNode(id));\n\n  const focusFirstNode = event => focus(event, getFirstNode());\n\n  const focusLastNode = event => focus(event, getLastNode());\n\n  const focusByFirstCharacter = (event, id, char) => {\n    let start;\n    let index;\n    const lowercaseChar = char.toLowerCase();\n    const firstCharIds = [];\n    const firstChars = []; // This really only works since the ids are strings\n\n    Object.keys(firstCharMap.current).forEach(nodeId => {\n      const firstChar = firstCharMap.current[nodeId];\n      const map = nodeMap.current[nodeId];\n      const visible = map.parentId ? isExpanded(map.parentId) : true;\n      const shouldBeSkipped = disabledItemsFocusable ? false : isDisabled(nodeId);\n\n      if (visible && !shouldBeSkipped) {\n        firstCharIds.push(nodeId);\n        firstChars.push(firstChar);\n      }\n    }); // Get start index for search based on position of currentItem\n\n    start = firstCharIds.indexOf(id) + 1;\n\n    if (start >= firstCharIds.length) {\n      start = 0;\n    } // Check remaining slots in the menu\n\n\n    index = findNextFirstChar(firstChars, start, lowercaseChar); // If not found in remaining slots, check from beginning\n\n    if (index === -1) {\n      index = findNextFirstChar(firstChars, 0, lowercaseChar);\n    } // If match was found...\n\n\n    if (index > -1) {\n      focus(event, firstCharIds[index]);\n    }\n  };\n  /*\n   * Expansion Helpers\n   */\n\n\n  const toggleExpansion = (event, value = focusedNodeId) => {\n    let newExpanded;\n\n    if (expanded.indexOf(value) !== -1) {\n      newExpanded = expanded.filter(id => id !== value);\n    } else {\n      newExpanded = [value].concat(expanded);\n    }\n\n    if (onNodeToggle) {\n      onNodeToggle(event, newExpanded);\n    }\n\n    setExpandedState(newExpanded);\n  };\n\n  const expandAllSiblings = (event, id) => {\n    const map = nodeMap.current[id];\n    const siblings = getChildrenIds(map.parentId);\n    const diff = siblings.filter(child => isExpandable(child) && !isExpanded(child));\n    const newExpanded = expanded.concat(diff);\n\n    if (diff.length > 0) {\n      setExpandedState(newExpanded);\n\n      if (onNodeToggle) {\n        onNodeToggle(event, newExpanded);\n      }\n    }\n  };\n  /*\n   * Selection Helpers\n   */\n\n\n  const lastSelectedNode = React.useRef(null);\n  const lastSelectionWasRange = React.useRef(false);\n  const currentRangeSelection = React.useRef([]);\n\n  const handleRangeArrowSelect = (event, nodes) => {\n    let base = selected.slice();\n    const {\n      start,\n      next,\n      current\n    } = nodes;\n\n    if (!next || !current) {\n      return;\n    }\n\n    if (currentRangeSelection.current.indexOf(current) === -1) {\n      currentRangeSelection.current = [];\n    }\n\n    if (lastSelectionWasRange.current) {\n      if (currentRangeSelection.current.indexOf(next) !== -1) {\n        base = base.filter(id => id === start || id !== current);\n        currentRangeSelection.current = currentRangeSelection.current.filter(id => id === start || id !== current);\n      } else {\n        base.push(next);\n        currentRangeSelection.current.push(next);\n      }\n    } else {\n      base.push(next);\n      currentRangeSelection.current.push(current, next);\n    }\n\n    if (onNodeSelect) {\n      onNodeSelect(event, base);\n    }\n\n    setSelectedState(base);\n  };\n\n  const handleRangeSelect = (event, nodes) => {\n    let base = selected.slice();\n    const {\n      start,\n      end\n    } = nodes; // If last selection was a range selection ignore nodes that were selected.\n\n    if (lastSelectionWasRange.current) {\n      base = base.filter(id => currentRangeSelection.current.indexOf(id) === -1);\n    }\n\n    let range = getNodesInRange(start, end);\n    range = range.filter(node => !isDisabled(node));\n    currentRangeSelection.current = range;\n    let newSelected = base.concat(range);\n    newSelected = newSelected.filter((id, i) => newSelected.indexOf(id) === i);\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const handleMultipleSelect = (event, value) => {\n    let newSelected;\n\n    if (selected.indexOf(value) !== -1) {\n      newSelected = selected.filter(id => id !== value);\n    } else {\n      newSelected = [value].concat(selected);\n    }\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const handleSingleSelect = (event, value) => {\n    const newSelected = multiSelect ? [value] : value;\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const selectNode = (event, id, multiple = false) => {\n    if (id) {\n      if (multiple) {\n        handleMultipleSelect(event, id);\n      } else {\n        handleSingleSelect(event, id);\n      }\n\n      lastSelectedNode.current = id;\n      lastSelectionWasRange.current = false;\n      currentRangeSelection.current = [];\n      return true;\n    }\n\n    return false;\n  };\n\n  const selectRange = (event, nodes, stacked = false) => {\n    const {\n      start = lastSelectedNode.current,\n      end,\n      current\n    } = nodes;\n\n    if (stacked) {\n      handleRangeArrowSelect(event, {\n        start,\n        next: end,\n        current\n      });\n    } else if (start != null && end != null) {\n      handleRangeSelect(event, {\n        start,\n        end\n      });\n    }\n\n    lastSelectionWasRange.current = true;\n  };\n\n  const rangeSelectToFirst = (event, id) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n    selectRange(event, {\n      start,\n      end: getFirstNode()\n    });\n  };\n\n  const rangeSelectToLast = (event, id) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n    selectRange(event, {\n      start,\n      end: getLastNode()\n    });\n  };\n\n  const selectNextNode = (event, id) => {\n    if (!isDisabled(getNextNode(id))) {\n      selectRange(event, {\n        end: getNextNode(id),\n        current: id\n      }, true);\n    }\n  };\n\n  const selectPreviousNode = (event, id) => {\n    if (!isDisabled(getPreviousNode(id))) {\n      selectRange(event, {\n        end: getPreviousNode(id),\n        current: id\n      }, true);\n    }\n  };\n\n  const selectAllNodes = event => {\n    selectRange(event, {\n      start: getFirstNode(),\n      end: getLastNode()\n    });\n  };\n  /*\n   * Mapping Helpers\n   */\n\n\n  const registerNode = React.useCallback(node => {\n    const {\n      id,\n      index,\n      parentId,\n      expandable,\n      idAttribute,\n      disabled\n    } = node;\n    nodeMap.current[id] = {\n      id,\n      index,\n      parentId,\n      expandable,\n      idAttribute,\n      disabled\n    };\n  }, []);\n  const unregisterNode = React.useCallback(id => {\n    const newMap = (0, _extends2.default)({}, nodeMap.current);\n    delete newMap[id];\n    nodeMap.current = newMap;\n    setFocusedNodeId(oldFocusedNodeId => {\n      if (oldFocusedNodeId === id && treeRef.current === (0, _utils.ownerDocument)(treeRef.current).activeElement) {\n        return getChildrenIds(null)[0];\n      }\n\n      return oldFocusedNodeId;\n    });\n  }, []);\n  const mapFirstChar = React.useCallback((id, firstChar) => {\n    firstCharMap.current[id] = firstChar;\n  }, []);\n  const unMapFirstChar = React.useCallback(id => {\n    const newMap = (0, _extends2.default)({}, firstCharMap.current);\n    delete newMap[id];\n    firstCharMap.current = newMap;\n  }, []);\n  /**\n   * Event handlers and Navigation\n   */\n\n  const handleNextArrow = event => {\n    if (isExpandable(focusedNodeId)) {\n      if (isExpanded(focusedNodeId)) {\n        focusNextNode(event, focusedNodeId);\n      } else if (!isDisabled(focusedNodeId)) {\n        toggleExpansion(event);\n      }\n    }\n\n    return true;\n  };\n\n  const handlePreviousArrow = event => {\n    if (isExpanded(focusedNodeId) && !isDisabled(focusedNodeId)) {\n      toggleExpansion(event, focusedNodeId);\n      return true;\n    }\n\n    const parent = getParent(focusedNodeId);\n\n    if (parent) {\n      focus(event, parent);\n      return true;\n    }\n\n    return false;\n  };\n\n  const handleKeyDown = event => {\n    let flag = false;\n    const key = event.key; // If the tree is empty there will be no focused node\n\n    if (event.altKey || event.currentTarget !== event.target || !focusedNodeId) {\n      return;\n    }\n\n    const ctrlPressed = event.ctrlKey || event.metaKey;\n\n    switch (key) {\n      case ' ':\n        if (!disableSelection && !isDisabled(focusedNodeId)) {\n          if (multiSelect && event.shiftKey) {\n            selectRange(event, {\n              end: focusedNodeId\n            });\n            flag = true;\n          } else if (multiSelect) {\n            flag = selectNode(event, focusedNodeId, true);\n          } else {\n            flag = selectNode(event, focusedNodeId);\n          }\n        }\n\n        event.stopPropagation();\n        break;\n\n      case 'Enter':\n        if (!isDisabled(focusedNodeId)) {\n          if (isExpandable(focusedNodeId)) {\n            toggleExpansion(event);\n            flag = true;\n          } else if (multiSelect) {\n            flag = selectNode(event, focusedNodeId, true);\n          } else {\n            flag = selectNode(event, focusedNodeId);\n          }\n        }\n\n        event.stopPropagation();\n        break;\n\n      case 'ArrowDown':\n        if (multiSelect && event.shiftKey && !disableSelection) {\n          selectNextNode(event, focusedNodeId);\n        }\n\n        focusNextNode(event, focusedNodeId);\n        flag = true;\n        break;\n\n      case 'ArrowUp':\n        if (multiSelect && event.shiftKey && !disableSelection) {\n          selectPreviousNode(event, focusedNodeId);\n        }\n\n        focusPreviousNode(event, focusedNodeId);\n        flag = true;\n        break;\n\n      case 'ArrowRight':\n        if (isRtl) {\n          flag = handlePreviousArrow(event);\n        } else {\n          flag = handleNextArrow(event);\n        }\n\n        break;\n\n      case 'ArrowLeft':\n        if (isRtl) {\n          flag = handleNextArrow(event);\n        } else {\n          flag = handlePreviousArrow(event);\n        }\n\n        break;\n\n      case 'Home':\n        if (multiSelect && ctrlPressed && event.shiftKey && !disableSelection && !isDisabled(focusedNodeId)) {\n          rangeSelectToFirst(event, focusedNodeId);\n        }\n\n        focusFirstNode(event);\n        flag = true;\n        break;\n\n      case 'End':\n        if (multiSelect && ctrlPressed && event.shiftKey && !disableSelection && !isDisabled(focusedNodeId)) {\n          rangeSelectToLast(event, focusedNodeId);\n        }\n\n        focusLastNode(event);\n        flag = true;\n        break;\n\n      default:\n        if (key === '*') {\n          expandAllSiblings(event, focusedNodeId);\n          flag = true;\n        } else if (multiSelect && ctrlPressed && key.toLowerCase() === 'a' && !disableSelection) {\n          selectAllNodes(event);\n          flag = true;\n        } else if (!ctrlPressed && !event.shiftKey && isPrintableCharacter(key)) {\n          focusByFirstCharacter(event, focusedNodeId, key);\n          flag = true;\n        }\n\n    }\n\n    if (flag) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n  };\n\n  const handleFocus = event => {\n    // if the event bubbled (which is React specific) we don't want to steal focus\n    if (event.target === event.currentTarget) {\n      const firstSelected = Array.isArray(selected) ? selected[0] : selected;\n      focus(event, firstSelected || getNavigableChildrenIds(null)[0]);\n    }\n\n    if (onFocus) {\n      onFocus(event);\n    }\n  };\n\n  const handleBlur = event => {\n    setFocusedNodeId(null);\n\n    if (onBlur) {\n      onBlur(event);\n    }\n  };\n\n  const activeDescendant = nodeMap.current[focusedNodeId] ? nodeMap.current[focusedNodeId].idAttribute : null;\n  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_TreeViewContext.default.Provider, {\n    value: {\n      icons: {\n        defaultCollapseIcon,\n        defaultExpandIcon,\n        defaultParentIcon,\n        defaultEndIcon\n      },\n      focus,\n      toggleExpansion,\n      isExpanded,\n      isExpandable,\n      isFocused,\n      isSelected,\n      isDisabled,\n      selectNode: disableSelection ? noopSelection : selectNode,\n      selectRange: disableSelection ? noopSelection : selectRange,\n      multiSelect,\n      disabledItemsFocusable,\n      mapFirstChar,\n      unMapFirstChar,\n      registerNode,\n      unregisterNode,\n      treeId\n    },\n    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_descendants.DescendantProvider, {\n      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(TreeViewRoot, (0, _extends2.default)({\n        role: \"tree\",\n        id: treeId,\n        \"aria-activedescendant\": activeDescendant,\n        \"aria-multiselectable\": multiSelect,\n        className: (0, _clsx.default)(classes.root, className),\n        ref: handleRef,\n        tabIndex: 0,\n        onKeyDown: handleKeyDown,\n        onFocus: handleFocus,\n        onBlur: handleBlur,\n        ownerState: ownerState\n      }, other, {\n        children: children\n      }))\n    })\n  });\n});\nprocess.env.NODE_ENV !== \"production\" ? TreeView.propTypes\n/* remove-proptypes */\n= {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n\n  /**\n   * The content of the component.\n   */\n  children: _propTypes.default.node,\n\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: _propTypes.default.object,\n\n  /**\n   * @ignore\n   */\n  className: _propTypes.default.string,\n\n  /**\n   * The default icon used to collapse the node.\n   */\n  defaultCollapseIcon: _propTypes.default.node,\n\n  /**\n   * The default icon displayed next to a end node. This is applied to all\n   * tree nodes and can be overridden by the TreeItem `icon` prop.\n   */\n  defaultEndIcon: _propTypes.default.node,\n\n  /**\n   * Expanded node ids. (Uncontrolled)\n   * @default []\n   */\n  defaultExpanded: _propTypes.default.arrayOf(_propTypes.default.string),\n\n  /**\n   * The default icon used to expand the node.\n   */\n  defaultExpandIcon: _propTypes.default.node,\n\n  /**\n   * The default icon displayed next to a parent node. This is applied to all\n   * parent nodes and can be overridden by the TreeItem `icon` prop.\n   */\n  defaultParentIcon: _propTypes.default.node,\n\n  /**\n   * Selected node ids. (Uncontrolled)\n   * When `multiSelect` is true this takes an array of strings; when false (default) a string.\n   * @default []\n   */\n  defaultSelected: _propTypes.default.oneOfType([_propTypes.default.arrayOf(_propTypes.default.string), _propTypes.default.string]),\n\n  /**\n   * If `true`, will allow focus on disabled items.\n   * @default false\n   */\n  disabledItemsFocusable: _propTypes.default.bool,\n\n  /**\n   * If `true` selection is disabled.\n   * @default false\n   */\n  disableSelection: _propTypes.default.bool,\n\n  /**\n   * Expanded node ids. (Controlled)\n   */\n  expanded: _propTypes.default.arrayOf(_propTypes.default.string),\n\n  /**\n   * This prop is used to help implement the accessibility logic.\n   * If you don't provide this prop. It falls back to a randomly generated id.\n   */\n  id: _propTypes.default.string,\n\n  /**\n   * If true `ctrl` and `shift` will trigger multiselect.\n   * @default false\n   */\n  multiSelect: _propTypes.default.bool,\n\n  /**\n   * @ignore\n   */\n  onBlur: _propTypes.default.func,\n\n  /**\n   * @ignore\n   */\n  onFocus: _propTypes.default.func,\n\n  /**\n   * @ignore\n   */\n  onKeyDown: _propTypes.default.func,\n\n  /**\n   * Callback fired when tree items are focused.\n   *\n   * @param {React.SyntheticEvent} event The event source of the callback **Warning**: This is a generic event not a focus event.\n   * @param {string} value of the focused node.\n   */\n  onNodeFocus: _propTypes.default.func,\n\n  /**\n   * Callback fired when tree items are selected/unselected.\n   *\n   * @param {React.SyntheticEvent} event The event source of the callback\n   * @param {string[] | string} nodeIds Ids of the selected nodes. When `multiSelect` is true\n   * this is an array of strings; when false (default) a string.\n   */\n  onNodeSelect: _propTypes.default.func,\n\n  /**\n   * Callback fired when tree items are expanded/collapsed.\n   *\n   * @param {React.SyntheticEvent} event The event source of the callback.\n   * @param {array} nodeIds The ids of the expanded nodes.\n   */\n  onNodeToggle: _propTypes.default.func,\n\n  /**\n   * Selected node ids. (Controlled)\n   * When `multiSelect` is true this takes an array of strings; when false (default) a string.\n   */\n  selected: _propTypes.default.oneOfType([_propTypes.default.arrayOf(_propTypes.default.string), _propTypes.default.string]),\n\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: _propTypes.default.oneOfType([_propTypes.default.arrayOf(_propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.object, _propTypes.default.bool])), _propTypes.default.func, _propTypes.default.object])\n} : void 0;\nvar _default = TreeView;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}